/**
 * This file was auto-generated by openapi-typescript.
 * Do not make direct changes to the file.
 */

import { components } from "react-select"
import { z } from "zod";



/**
* This file was auto-generated by openapi-typescript.
* Do not make direct changes to the file.
*/
export type InferImageResponse =
    components["schemas"]["InferImageResponse"]
export type MangaDirViewResponse =
    components["schemas"]["MangaDirViewResponse"]
export type MediaNamespace =
    components["schemas"]["MediaNamespace"]

export const MEDIA_NAMESPACES = [
    "inputs",
    "outputs",
] as const satisfies readonly MediaNamespace[]

//make this read-only so a mediaRef is never mutated
export type MediaRef =
    Readonly<components["schemas"]["MediaRef"]>

export function mediaBasename(ref: MediaRef): string {
    return ref.path.split("/").filter(Boolean).pop() ?? "";
}

export function mediaDirname(ref: MediaRef): string {
    return ref.path.split("/").slice(0, -1).join("/");
}

export type PaddleAugmentedOCRRunResponse =
    components["schemas"]["PaddleAugmentedOCRRunResponse"]
export type PaddleBBox =
    components["schemas"]["PaddleBBox"]
export type PaddleDialogueLineResponse =
    components["schemas"]["PaddleDialogueLineResponse"]
export type PaddleOCRImage =
    components["schemas"]["PaddleOCRImage"]

export const LatestTTSResponseSchema = z.object({
    status: z.enum(["success", "error"]),
    audio_path: z.string().nullable(),
    error: z.string().nullable(),
})

export type LatestTTSResponse =
    z.infer<typeof LatestTTSResponseSchema>
/**
 * This file was auto-generated by openapi-typescript.
 * Do not make direct changes to the file.
 */

export interface paths {
    "/api/manga/dir/": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** List folders and images */
        get: {
            parameters: {
                query?: never;
                header?: never;
                path?: never;
                cookie?: never;
            };
            requestBody?: never;
            responses: {
                /** @description Success */
                200: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["MangaDirViewResponse"];
                    };
                };
            };
        };
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/manga/json_file/": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Load results from JSON file, which is the output from OCR API */
        get: {
            parameters: {
                query?: never;
                header?: never;
                path?: never;
                cookie?: never;
            };
            requestBody?: never;
            responses: {
                /** @description Success */
                200: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["PaddleAugmentedOCRRunResponse"];
                    };
                };
            };
        };
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/manga/latest_audio/": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Load LATEST version audio file generated from TTS API */
        get: {
            parameters: {
                query?: never;
                header?: never;
                path?: never;
                cookie?: never;
            };
            requestBody?: never;
            responses: {
                /** @description Success */
                200: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["LatestTTSResponse"];
                    };
                };
            };
        };
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
}
export type webhooks = Record<string, never>;
export interface components {
    schemas: {
        /** MangaDirViewResponse */
        MangaDirViewResponse: {
            /** Folders */
            folders: components["schemas"]["MediaRef"][];
            /** Files */
            files: components["schemas"]["MediaRef"][];
        };
        /**
         * MediaNamespace
         * @enum {string}
         */
        MediaNamespace: "inputs" | "outputs";
        /** MediaRef */
        MediaRef: {
            namespace: components["schemas"]["MediaNamespace"];
            /** Path */
            path: string;
        };
        /** PaddleAugmentedOCRRunResponse */
        PaddleAugmentedOCRRunResponse: {
            /** Run Id */
            run_id: string;
            /** Imageresults */
            imageResults: components["schemas"]["PaddleOCRImage"][];
            /**
             * Error
             * @default null
             */
            error: string | null;
            ocr_json_file: components["schemas"]["MediaRef"];
        };
        /** InferImageResponse */
        InferImageResponse: {
            image_ref: components["schemas"]["MediaRef"];
            /** Image Text */
            image_text: unknown;
            /** Image Width */
            image_width: number;
            /** Image Height */
            image_height: number;
            /** Input Tokens */
            input_tokens: number;
            /** Output Tokens */
            output_tokens: number;
            /** Throughput */
            throughput: number;
        };
        /** PaddleBBox */
        PaddleBBox: {
            /** X1 */
            x1: number;
            /** Y1 */
            y1: number;
            /** X2 */
            x2: number;
            /** Y2 */
            y2: number;
            /** Poly */
            poly: number[][];
            /** Matched Rec Text Index */
            matched_rec_text_index: number;
            /** Matched Rec Text Index Orig */
            matched_rec_text_index_orig: number;
        };
        /** PaddleDialogueLineResponse */
        PaddleDialogueLineResponse: {
            /** Id */
            id: number;
            /** Image Id */
            image_id: string;
            /** Speaker */
            speaker: string;
            /** Gender */
            gender: string;
            /** Emotion */
            emotion: string;
            /** Text */
            text: string;
            paddlebbox: components["schemas"]["PaddleBBox"];
        };
        /** PaddleOCRImage */
        PaddleOCRImage: {
            /** Image Id */
            image_id: string;
            inferImageRes: components["schemas"]["InferImageResponse"];
            /** Parseddialoguelines */
            parsedDialogueLines: components["schemas"]["PaddleDialogueLineResponse"][];
            /**
             * Paddleocr Result
             * @default null
             */
            paddleocr_result: unknown | null;
        };
        /** LatestTTSResponse */
        LatestTTSResponse: {
            /** Status */
            status: string;
            /** Audio Path */
            audio_path: string | null;
            /** Error */
            error: string | null;
        };
    };
    responses: never;
    parameters: never;
    requestBodies: never;
    headers: never;
    pathItems: never;
}
export type $defs = Record<string, never>;
export type operations = Record<string, never>;
