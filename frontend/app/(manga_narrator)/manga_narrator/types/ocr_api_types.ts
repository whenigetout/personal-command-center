/**
 * This file was auto-generated by openapi-typescript.
 * Do not make direct changes to the file.
 */

// ===============================
// Clean domain type aliases
// (do NOT edit generated section above)
// ===============================

type MediaNamespace =
    components["schemas"]["MediaNamespace"]

type MediaRef =
    components["schemas"]["MediaRef"];

type InferImageResponse =
    components["schemas"]["InferImageResponse"];

type PaddleBBox =
    components["schemas"]["PaddleBBox"];

type PaddleDialogueLineResponse =
    components["schemas"]["PaddleDialogueLineResponse"];

type PaddleResizeInfo =
    components["schemas"]["PaddleResizeInfo"];

type PaddleOCRImage =
    components["schemas"]["PaddleOCRImage"];

type PaddleAugmentedOCRRunResponse =
    components["schemas"]["PaddleAugmentedOCRRunResponse"];

// ===============================
// State-refined / guaranteed shapes
// Mirrors domain_states.py
// ===============================

export type PaddleReadyDialogueLine =
    PaddleDialogueLineResponse & {
        paddlebbox: PaddleBBox & {
            poly: number[][];
            matched_rec_text_index: number;
            matched_rec_text_index_orig: number;
        };
    };

export type PaddleReadyOCRImage =
    PaddleOCRImage & {
        parsedDialogueLines: PaddleReadyDialogueLine[];
    };

export type PaddleReadyOCRRun =
    PaddleAugmentedOCRRunResponse & {
        imageResults: PaddleReadyOCRImage[];
    };

/**
 * This file was auto-generated by openapi-typescript.
 * Do not make direct changes to the file.
 */

export interface paths {
    "/paddle_augmented_ocr_run": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Schema Paddle Augmented Ocr Run
         * @description Schema-only endpoint.
         *
         *     This endpoint exists solely to expose the
         *     PaddleAugmentedOCRRunResponse model to OpenAPI
         *     so frontend tooling can generate types.
         *
         *     Do not call this endpoint at runtime.
         */
        get: operations["schema_paddle_augmented_ocr_run_paddle_augmented_ocr_run_get"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/ocr/run_paddle": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /** Run Paddle */
        post: operations["run_paddle_ocr_run_paddle_post"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/ocr/folder": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /** Ocr From Folder */
        post: operations["ocr_from_folder_ocr_folder_post"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/ocr/results": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Get Ocr Results */
        get: operations["get_ocr_results_ocr_results_get"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/debug/map_paddle_bboxes": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Debug Map Paddle Bboxes
         * @description Debug endpoint to test mapPaddleBBoxes() in isolation.
         *     Calls the existing function directly. No duplicated logic.
         */
        post: operations["debug_map_paddle_bboxes_debug_map_paddle_bboxes_post"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
}
export type webhooks = Record<string, never>;
export interface components {
    schemas: {
        /** Body_debug_map_paddle_bboxes_debug_map_paddle_bboxes_post */
        Body_debug_map_paddle_bboxes_debug_map_paddle_bboxes_post: {
            /**
             * Json Path
             * @description Path to *_with_paddle.json or paddle-augmented OCR JSON
             */
            json_path: string;
            /**
             * Annotate Bboxes
             * @description Whether to also save annotated images
             * @default false
             */
            annotate_bboxes: boolean;
        };
        /** Body_ocr_from_folder_ocr_folder_post */
        Body_ocr_from_folder_ocr_folder_post: {
            /**
             * Input Path
             * @description Relative path under media_root/inputs/, e.g. test_mangas/test_manga1
             */
            input_path: string;
        };
        /** Body_run_paddle_ocr_run_paddle_post */
        Body_run_paddle_ocr_run_paddle_post: {
            /**
             * Input Path
             * @description Relative path of json file under media_root/outputs/, e.g. test_mangas/test_manga1/ocr_json.json
             */
            input_path: string;
        };
        /** HTTPValidationError */
        HTTPValidationError: {
            /** Detail */
            detail?: components["schemas"]["ValidationError"][];
        };
        /** InferImageResponse */
        InferImageResponse: {
            image_ref: components["schemas"]["MediaRef"];
            /** Image Text */
            image_text: unknown;
            /** Image Width */
            image_width: number;
            /** Image Height */
            image_height: number;
            /** Input Tokens */
            input_tokens: number;
            /** Output Tokens */
            output_tokens: number;
            /** Throughput */
            throughput: number;
        };
        /**
         * MediaNamespace
         * @enum {string}
         */
        MediaNamespace: "inputs" | "outputs";
        /** MediaRef */
        MediaRef: {
            namespace: components["schemas"]["MediaNamespace"];
            /** Path */
            path: string;
        };
        /** PaddleAugmentedOCRRunResponse */
        PaddleAugmentedOCRRunResponse: {
            /** Run Id */
            run_id: string;
            /** Imageresults */
            imageResults?: components["schemas"]["PaddleOCRImage"][] | null;
            /** Error */
            error?: string | null;
            ocr_json_file: components["schemas"]["MediaRef"];
        };
        /** PaddleBBox */
        PaddleBBox: {
            /** X1 */
            x1: number;
            /** Y1 */
            y1: number;
            /** X2 */
            x2: number;
            /** Y2 */
            y2: number;
            /** Poly */
            poly?: number[][] | null;
            /** Matched Rec Text Index */
            matched_rec_text_index?: number | null;
            /** Matched Rec Text Index Orig */
            matched_rec_text_index_orig?: number | null;
        };
        /** PaddleDialogueLineResponse */
        PaddleDialogueLineResponse: {
            /** Id */
            id: number;
            /** Image Id */
            image_id: string;
            /** Speaker */
            speaker: string;
            /** Gender */
            gender: string;
            /** Emotion */
            emotion: string;
            /** Text */
            text: string;
            paddlebbox?: components["schemas"]["PaddleBBox"] | null;
        };
        /** PaddleOCRImage */
        PaddleOCRImage: {
            /** Image Id */
            image_id: string;
            inferImageRes?: components["schemas"]["InferImageResponse"] | null;
            /** Parseddialoguelines */
            parsedDialogueLines?: components["schemas"]["PaddleDialogueLineResponse"][] | null;
            paddleResizeInfo?: components["schemas"]["PaddleResizeInfo"] | null;
            /** Paddleocr Result */
            paddleocr_result?: unknown | null;
        };
        /** PaddleResizeInfo */
        PaddleResizeInfo: {
            /** Original H */
            original_h: number;
            /** Original W */
            original_w: number;
            /** Resized H */
            resized_h: number;
            /** Resized W */
            resized_w: number;
            /** Ratio H */
            ratio_h: number;
            /** Ratio W */
            ratio_w: number;
        };
        /** ValidationError */
        ValidationError: {
            /** Location */
            loc: (string | number)[];
            /** Message */
            msg: string;
            /** Error Type */
            type: string;
        };
    };
    responses: never;
    parameters: never;
    requestBodies: never;
    headers: never;
    pathItems: never;
}
export type $defs = Record<string, never>;
export interface operations {
    schema_paddle_augmented_ocr_run_paddle_augmented_ocr_run_get: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["PaddleAugmentedOCRRunResponse"];
                };
            };
        };
    };
    run_paddle_ocr_run_paddle_post: {
        parameters: {
            query?: {
                annotate_bboxes?: boolean | null;
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/x-www-form-urlencoded": components["schemas"]["Body_run_paddle_ocr_run_paddle_post"];
            };
        };
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": unknown;
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    ocr_from_folder_ocr_folder_post: {
        parameters: {
            query?: {
                output_all_results_to_json?: boolean | null;
                attach_bboxes?: boolean | null;
                annotate_bboxes?: boolean | null;
                custom_prompt?: string | null;
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/x-www-form-urlencoded": components["schemas"]["Body_ocr_from_folder_ocr_folder_post"];
            };
        };
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": unknown;
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    get_ocr_results_ocr_results_get: {
        parameters: {
            query: {
                /** @description The run ID of the OCR batch */
                run_id: string;
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": unknown;
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    debug_map_paddle_bboxes_debug_map_paddle_bboxes_post: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/x-www-form-urlencoded": components["schemas"]["Body_debug_map_paddle_bboxes_debug_map_paddle_bboxes_post"];
            };
        };
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": unknown;
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
}
